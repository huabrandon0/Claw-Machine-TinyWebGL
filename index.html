<!-- Graphics Example Code.  index.html - The web page document containing the canvas (drawing surface), that launches your javascript files.  By Garett //-->
<!DOCTYPE html> <html> <head> <meta charset="UTF-8"/> <link rel="icon" href="assets/fav.ico">
<script type="text/javascript" src="tinywebgl-ucla.js" ></script>  <!--  Javascript "include" files.  Any code in them gets executed as part of the page loading. //-->
<script type="text/javascript" src="dependencies.js"   ></script>
<script type="text/javascript"> "use strict"    
  window.onload = function init()        // ********************* THE ENTRY POINT OF THE WHOLE PROGRAM STARTS HERE ********************* 
    { window.contexts = {};                                                            // A global variable, "contexts".  Browsers support up to 16 WebGL contexts per page.
      
      const scenes  = ["Animation_Manager", "My_Animation", "Movement_Controls", "Global_Info_Table", "Gameplay_Controls" ]; // Register some scenes to the "Canvas_Manager" object -- which WebGL calls
                                                                                       // upon every time a draw / keyboard / mouse event happens.  
      
      if( eval( "typeof " + scenes[0] ) !== "undefined" )
      { document.getElementById( "canvases" ).appendChild( Object.assign( document.createElement( "canvas" ), { id: "main_canvas", width: 800, height: 600 } ) );
        contexts[ "main_canvas" ] = new Canvas_Manager( "main_canvas", Color.of( 0,0,0,1 ), scenes );   // Manage the WebGL canvas.  Second parameter sets background color.
        for( let c in contexts ) contexts[ c ].render();     // Call render() for each WebGL context on this page.  Then render() will re-queue itself for more calls.
        
        Code_Manager.display_code( eval( scenes[0] ) );                                  // Display the code for our demo on the page, starting with the first scene in the list.
        for( let list of [ core_dependencies, all_dependencies ] )
        document.querySelector( "#class_list" ).rows[2].appendChild( Object.assign( document.createElement( "td" ), { 
          innerHTML: list.reduce( (acc, x) => acc += "<a href='javascript:void(0);' onclick='Code_Manager.display_code(" + x + ")'>" + x + "</a><br>", "" ) } ) );        
        document.getElementsByName( "main_demo_link" )[0].innerHTML = "<a href='javascript:void(0);' onclick='Code_Manager.display_code(" + scenes[0] + ")'>" + scenes[0] + "</a><br>";
        document.querySelector("#code_display").innerHTML = "Below is the code for the demo that's running:<br>&nbsp;<br>" + document.querySelector("#code_display").innerHTML;             
      }
      
      document.querySelector("#edit_button").addEventListener('click', () => {
        code_panel.style.display=class_list.style.display='none'; new_demo_source_code.style.display='block'; 
        document.getElementsByName( 'new_demo_code' )[0].value=code_display.dataset.displayed.toString() } )
      const form = document.forms.namedItem("new_demo_source_code");
      form.addEventListener('submit', function(event) 
        { if( document.getElementsByName( "finished" )[0].checked )
            alert( "Your demo will be submitted.  If approved, you will start being asked for a password to make any further updates to it.  This password "
                 + "will appear right now, below the submit button, and then (assuming submission worked) it will never appear again.  Write it down." );
          let xhr = new XMLHttpRequest();
          xhr.open("POST", "/submit-demo?Unapproved", true);
          xhr.responseType = "json";
          xhr.onload = function(event) 
          { if (xhr.status != 200) { document.querySelector("#submit_result").textContent = "Error " + xhr.status + " when trying to upload."; return }
            document.querySelector("#submit_result").textContent = this.response.message;
            // if( this.response.hide_finished_checkbox ) { document.getElementsByName( "finished" )[0].checked = false; expert_panel.style.display = "none" }
            if( this.response.show_password  ) document.getElementsByName( "password" )[0] .style.display = "inline";
            if( this.response.show_overwrite ) document.querySelector( "#overwrite_panel" ).style.display = "inline";
          };
          xhr.setRequestHeader("Content-Type", "application/json");
          xhr.send( JSON.stringify( Array.from( form.elements ).reduce( ( accum, elem ) => 
            { if( elem.value && !( ['checkbox', 'radio'].includes(elem.type) && !elem.checked ) ) accum[elem.name] = elem.value; return accum }, {} ) ) );
          event.preventDefault();
        }, false);      
    }

class Animation_Manager extends Scene_Component
{
  constructor( context, canvas = context.canvas )
    {
      super( context );
      
      // Whether the target of the controls is the claw
      this.target_is_claw = function() { return context.globals.target_is_claw }
      context.globals.target_is_claw = false;
      
      // Camera transform
      this.get_cam_tf = function() { return context.globals.graphics_state.camera_transform }
      this.set_cam_tf = function( new_cam_tf ) { context.globals.graphics_state.camera_transform = new_cam_tf };
      
      // Flag: drop animation
      this.is_grabbing = function() { return context.globals.is_grabbing };
      context.globals.is_grabbing = false;
      
      // Flag: return animation
      this.is_returning = function() { return context.globals.is_returning };
      context.globals.is_returning = false;
      
      // Claw transform
      this.get_claw_tf = function() { return context.globals.claw_tf };
      this.set_claw_tf = function( new_claw_tf ) { context.globals.claw_tf = new_claw_tf };
      
      // Flag: grip animation
      this.is_gripping_claw = function() { return context.globals.is_gripping_claw };
      context.globals.is_gripping_claw = false;
      
      // Flag: release animation
      this.is_releasing_claw = function() { return context.globals.is_releasing_claw };
      context.globals.is_releasing_claw = false;
      
      // Claw arm rotation transform
      this.get_claw_rot_tf = function() { return context.globals.claw_rot_tf }; // Not used
      this.set_claw_rot_tf = function( new_claw_rot_tf ) { context.globals.claw_rot_tf = new_claw_rot_tf }; // Not used
      context.globals.claw_rot_tf = Mat4.identity();
      
      // Flag: drop prize animation
      this.is_dropping_prize = function() { return context.globals.is_dropping_prize };
      context.globals.is_dropping_prize = false;
      
      // Item picked-up boolean
			this.set_item_picked_up = function(x) { context.globals.item_picked_up = x; };
      this.get_item_picked_up = function() { return context.globals.item_picked_up };
      context.globals.item_picked_up = false;
      
      // Prize transform
      this.get_prize_tf = function() { return context.globals.prize_tf };
      this.set_prize_tf = function( new_prize_tf ) { context.globals.prize_tf = new_prize_tf };
      context.globals.prize_tf = Mat4.identity();
      
      // Picked up item transform
      this.get_pickup_tf = function() { return context.globals.pickup_tf };
      this.set_pickup_tf = function( new_pickup_tf ) { context.globals.pickup_tf = new_pickup_tf };
      context.globals.pickup_tf = Mat4.identity();
      
      // Claw actual velocity
      this.get_claw_velocity = function() { return context.globals.claw_velocity };
      this.set_claw_velocity = function( new_vel ) { context.globals.claw_velocity = new_vel };
      context.globals.claw_velocity = Vec.of( 0, 0, 0 );
      
      // Drop claw coroutine
      this.grab_animation = this.coroutine( function*()
        {
          while (true)
            {
              while (!context.globals.is_grabbing)
                {
                  yield;
                }
              
              ///////////////////////
              // Lowering the claw //
              ///////////////////////
              
              let total_time = 1000; //change l8r lol
              let start_time = context.globals.graphics_state.animation_time;
              let duration_time = context.globals.graphics_state.animation_time - start_time;
              
              let drop_height = 28;
              let raised_pos = context.globals.claw_tf;
              let lowered_pos = raised_pos.times( Mat4.translation( Vec.of( 0, -1 * drop_height, 0 ) ) );
              
              while ( duration_time < total_time )
                {
                  yield;
                  context.globals.claw_tf = raised_pos.times( Mat4.translation( Vec.of( 0, -1 * drop_height * ( duration_time/total_time ), 0 ) ) ).times( Mat4.rotation( 0.05 * Math.sin( 2*Math.PI * duration_time/total_time ), Vec.of( 0, 1, 0 ) ) );
                  duration_time = context.globals.graphics_state.animation_time - start_time;
                  context.globals.claw_velocity = Vec.of( 0, -1, 0 );
                }
              
              // Making the claw exactly in dropped position
              context.globals.claw_tf = lowered_pos;
              
              // Time delay for suspense for the release
							total_time = 200;
              start_time = context.globals.graphics_state.animation_time;
              duration_time = context.globals.graphics_state.animation_time - start_time;
							
							while ( duration_time < total_time )
							{
								yield;
								duration_time = context.globals.graphics_state.animation_time - start_time;
							}
              
              ///////////////////////////////////
              // Switch to grip_claw_animation //
              ///////////////////////////////////
              
              context.globals.is_gripping_claw = true;
              while ( context.globals.is_gripping_claw )
                {
                  yield;
                }
              
              //////////////////////
              // Raising the claw //
              //////////////////////
              
              total_time = 1000; //change l8r lol
              start_time = context.globals.graphics_state.animation_time;
              duration_time = context.globals.graphics_state.animation_time - start_time;
              
              while ( duration_time < total_time )
                {
                  yield;
                  context.globals.claw_tf = lowered_pos.times( Mat4.translation( Vec.of( 0, drop_height * ( duration_time/total_time ), 0 ) ) );
                  duration_time = context.globals.graphics_state.animation_time - start_time;
                  context.globals.claw_velocity = Vec.of( 0, 1, 0 );
                }
              
              // Making the claw exactly in raised position
              context.globals.claw_tf = raised_pos;
							
              // Time delay for suspense for the release
							total_time = 200;
              start_time = context.globals.graphics_state.animation_time;
              duration_time = context.globals.graphics_state.animation_time - start_time;
							
							while ( duration_time < total_time )
							{
								yield;
								duration_time = context.globals.graphics_state.animation_time - start_time;
							}
              
							// STOP GRAB ANIMATION, START RETURN ANIMATION
              context.globals.is_returning = true;
              context.globals.is_grabbing = false;
            }
        });
        
      // Return claw and drop item coroutine
      this.return_animation = this.coroutine( function*()
        {
          while (true)
            {
              while (!context.globals.is_returning)
                {
                  yield;
                }
              
              //////////////////////////////////////////
              // Returning to drop-off position x_min //
              //////////////////////////////////////////
              
              let x_min = -10;
              let x_thrust = Vec.of( 1, 0, 0 );
              
              while ( context.globals.claw_tf[0][3] > x_min )
              {
                yield;
                let meters_per_frame = context.globals.graphics_state.animation_delta_time/50;
                context.globals.claw_tf.post_multiply( Mat4.translation( x_thrust.times( -meters_per_frame ) ) );
                context.globals.claw_velocity = x_thrust;
              }
              
              context.globals.claw_tf[0][3] = x_min;
              
              //////////////////////////////////////////
              // Returning to drop-off position z_max //
              //////////////////////////////////////////
              
              let z_max = 10;
              let z_thrust = Vec.of( 0, 0, -1 );
              
              while ( context.globals.claw_tf[2][3] < z_max )
              {
                yield;
                let meters_per_frame = context.globals.graphics_state.animation_delta_time/50;
                context.globals.claw_tf.post_multiply( Mat4.translation( z_thrust.times( -meters_per_frame ) ) );
                context.globals.claw_velocity = z_thrust;
              }
              
              context.globals.claw_tf[2][3] = z_max;
              
							// Time delay for suspense for the release
							let total_time = 500;
              let start_time = context.globals.graphics_state.animation_time;
              let duration_time = context.globals.graphics_state.animation_time - start_time;
							
							while ( duration_time < total_time )
							{
								yield;
								duration_time = context.globals.graphics_state.animation_time - start_time;
							}
							
							/////////////////////////////////////////
              // Switching to release_claw_animation //
              /////////////////////////////////////////
              
              context.globals.is_releasing_claw = true;
              while ( context.globals.is_releasing_claw )
                {
                  yield;
                }
							
							// Set flag off
              context.globals.is_returning = false;
            }
        });
        
        this.grip_claw_animation = this.coroutine( function*()
        {
          while (true)
            {
              while (!context.globals.is_gripping_claw)
                {
                  yield;
                }
              
              // Useful animation variables
              let total_time = 0;
              let start_time = 0;
              let duration_time = 0;
                
              /////////////////////////////
              // Gripping with the claws //
              /////////////////////////////
              
              total_time = 1000;
              start_time = context.globals.graphics_state.animation_time;
              duration_time = context.globals.graphics_state.animation_time - start_time;
              
              //cip
              <!-- let orig_pickup_tf = context.globals.pickup_tf; -->
              <!-- let end_pickup_tf = context.globals.prize_tf; -->
              
              <!-- let orig_pickup_pos = orig_pickup_tf.times( Vec.of( 0, 0, 0, 1 ) ); -->
              <!-- let end_pickup_pos = end_pickup_tf.times( Vec.of( 0, 0, 0, 1 ) ); -->
              <!-- let orig_to_end_vec = orig_pickup_pos.minus( end_pickup_pos ).to3(); -->
              <!-- console.log(orig_pickup_pos) -->
              <!-- console.log(end_pickup_tf) -->
              <!-- console.log(orig_to_end_vec) -->
              
							let grip_amplitude = Math.PI/12;
							
              while ( duration_time < total_time )
                {
                  yield;
                  context.globals.claw_rot_tf = Mat4.rotation( grip_amplitude * ( Math.sin( Math.PI/2 * duration_time/total_time ) ), Vec.of( 1, 0, 0 ) );
                 
                  //cip
                  <!-- // interp pickup_item_tf to prize_tf -->
                  <!-- context.globals.pickup_tf = orig_pickup_tf.times( Mat4.translation( orig_to_end_vec.times( duration_time/total_time ) ) ); -->
                  
                  duration_time = context.globals.graphics_state.animation_time - start_time;
                }
              
              // Making the claw exactly in gripped position
              context.globals.claw_rot_tf = Mat4.rotation( grip_amplitude, Vec.of( 1, 0, 0 ) );
              
              // Set flag off
              context.globals.is_gripping_claw = false;
            }
        });
        
        this.release_claw_animation = this.coroutine( function*()
        {
          while (true)
            {
              while (!context.globals.is_releasing_claw)
                {
                  yield;
                }
              
              // Useful animation variables
              let total_time = 0;
              let start_time = 0;
              let duration_time = 0;
                
              /////////////////////////////
              // Releasing the claw grip //
              /////////////////////////////
              
              total_time = 150;
              start_time = context.globals.graphics_state.animation_time;
              duration_time = context.globals.graphics_state.animation_time - start_time;
              
              let release_amplitude = Math.PI/12;
              
              while ( duration_time < total_time )
                {
                  yield;
                  context.globals.claw_rot_tf = Mat4.rotation( release_amplitude *( 1 - ( Math.sin( Math.PI/2 * duration_time/total_time ) ) ), Vec.of( 1, 0, 0 ) );
                  
                  // Drop the prize
                  if (context.globals.item_picked_up && duration_time/total_time > 0.1)
                    {
                      context.globals.is_dropping_prize = true;
                    }
                    
                  duration_time = context.globals.graphics_state.animation_time - start_time;
                }
              
              // Making the claw exactly in neutral position
              context.globals.claw_rot_tf = Mat4.identity();
                
              // Set flag off
              context.globals.is_releasing_claw = false;
            }
        });
        
        this.drop_prize_animation = this.coroutine( function*()
        {
          while (true)
            {
              while (!context.globals.is_dropping_prize)
                {
                  yield;
                }
              
              // Useful animation variables
              let total_time = 0;
              let start_time = 0;
              let duration_time = 0;
                
              ////////////////////////
              // Dropping the prize //
              ////////////////////////
              
              total_time = 1000;
              start_time = context.globals.graphics_state.animation_time;
              duration_time = context.globals.graphics_state.animation_time - start_time;
              
              let orig_prize_tf = context.globals.prize_tf;
              
              while ( duration_time < total_time )
                {
                  yield;
                  let y_coord_due_to_gravity = -1 * Math.pow( 9.8/1000  * duration_time, 2 );
                  let falling_rotation = Mat4.rotation( 4 * duration_time / total_time, Vec.of( 1, 1, 1 ) )
                  
                  context.globals.prize_tf = orig_prize_tf.times( Mat4.translation( Vec.of( 0, y_coord_due_to_gravity, 2 ), 0 ) ).times( falling_rotation );
                    
                  if ( y_coord_due_to_gravity < -40 )
                    {
                      context.globals.prize_tf = orig_prize_tf.times( Mat4.translation( Vec.of( 0, -40, 0 ) ) );
                    }
                  
                  duration_time = context.globals.graphics_state.animation_time - start_time;
                }
              
              //context.globals.prize_tf = orig_prize_tf.times( Mat4.translation( Vec.of( 0, -30, 0 ) ) );
              context.globals.prize_tf = orig_prize_tf.times( Mat4.translation( Vec.of( 0, -40, 0 ) ) );
              
              // Set item_picked_up flag off
							context.globals.item_picked_up = false;
              
              // Set items_won array, assuming an item was picked up
              context.globals.items_won[context.globals.item_num] = true;
              
              // Set flag off
              context.globals.is_dropping_prize = false;
            }
        });
    }
  
  coroutine(f)
    {
      let o = f(); // instantiate the coroutine
      o.next(); // execute until the first yield
      return function(x)
        {
          o.next(x);
        }
    }

  display( graphics_state, dt = graphics_state.animation_delta_time )
    {
      if ( this.target_is_claw() )
        {
          // Default cam
          this.set_cam_tf( Mat4.look_at( Vec.of( 0, 40, 70 ), this.get_claw_tf().times( Vec.of( 0, 0, 0, 1 ) ).to3().minus( Vec.of( 0, 25, 0 ) ), Vec.of( 0, 1, 0 ) ) );
        
          if ( this.is_grabbing() )
            {
              this.grab_animation();
              
              if ( this.is_gripping_claw() )
                {
                  this.grip_claw_animation();
                }
              
              // Follow claw close-up
              this.set_cam_tf( Mat4.look_at( Vec.of( 0, 10, 40 ), this.get_claw_tf().times( Vec.of( 0, 0, 0, 1 ) ).to3().minus( Vec.of( 0, 5, 0 ) ), Vec.of( 0, 1, 0 ) ) );
            }
          
          if ( this.is_returning() )
            {
              this.return_animation();
              
              if ( this.is_releasing_claw() )
                {
                  this.release_claw_animation();
                }
            }
          
          if ( this.get_item_picked_up() )
            {
              if ( this.is_dropping_prize() )
                {
                  this.drop_prize_animation();
                  
                  // Watch prize drop close up
                  this.set_cam_tf( Mat4.look_at( Vec.of( -13, -10, 30 ), this.get_prize_tf().times( Vec.of( 0, 0, 0, 1 ) ).to3(), Vec.of( 0, 1, 0 ) ) );
                }
              else
                {
                  this.set_prize_tf( this.get_claw_tf().times( Mat4.translation( Vec.of( 0, -5, 0 ) ) ) )
                }
                
              if ( !this.is_grabbing() )
              {
                this.set_pickup_tf( this.get_prize_tf() );
              }
            }
        }
    }
}

class Gameplay_Controls extends Scene_Component
{ constructor( context, canvas = context.canvas )
    { super( context );
      Object.assign( this,
              { w_key: 0,
                a_key: 0,
                s_key: 0,
                d_key: 0,
                z_key: 0,
                space_key: 0,
                enter_key: 0,
                thrust: Vec.of(0,0,0)
              } );
      
      // Claw transform
      context.globals.claw_tf = Mat4.translation( Vec.of( 0, 35, 0 ) );
      this.get_claw_tf = function() { return context.globals.claw_tf };
      this.set_claw_tf = function( new_claw_tf ) { context.globals.claw_tf = new_claw_tf };
      
      // Whether the target of the controls is the claw
      this.target_is_claw = function() { return context.globals.target_is_claw }
      
      // Whether the drop claw animation is playing
      this.is_grabbing = function() { return context.globals.is_grabbing };
      
      // Whether the return claw animation is playing
      this.is_returning = function() { return context.globals.is_returning };
      
      // Flag: drop prize animation
      this.is_dropping_prize = function() { return context.globals.is_dropping_prize };
      
      // Whether the target of the controls is the claw
      this.target_is_claw = function() { return context.globals.target_is_claw }
      context.globals.target_is_claw = false;
      
      // Joystick rotation transform
      context.globals.joystick_rot_tf = Mat4.identity();
      this.get_joystick_rot_tf = function() { return context.globals.joystick_rot_tf };
      this.set_joystick_rot_tf = function( new_joystick_rot_tf ) { context.globals.joystick_rot_tf = new_joystick_rot_tf };
      
      // Flag: button pressed
      context.globals.button_pressed = false;
      this.get_button_pressed = function() { return context.globals.button_pressed };
      this.set_button_pressed = function( new_button_pressed ) { context.globals.button_pressed = new_button_pressed };
      
      // Claw actual velocity
      this.get_claw_velocity = function() { return context.globals.claw_velocity };
      this.set_claw_velocity = function( new_vel ) { context.globals.claw_velocity = new_vel };
      context.globals.claw_velocity = Vec.of( 0, 0, 0 );
    }
    
  make_control_panel()   // This function of a scene sets up its keyboard shortcuts.
    { const globals = this.globals;
      this.control_panel.innerHTML += "Gameplay controls:<br>WASD to move.<br>Space to drop the claw.<br>";
      this.key_triggered_button( "Forward",    "w", function() { this.w_key = 1; }, undefined, function() { this.w_key = 0; } ); this.new_line();
      this.key_triggered_button( "Left",       "a", function() { this.a_key = 1; }, undefined, function() { this.a_key = 0; } ); this.new_line();
      this.key_triggered_button( "Back",       "s", function() { this.s_key = 1; }, undefined, function() { this.s_key = 0; } ); this.new_line();
      this.key_triggered_button( "Right",      "d", function() { this.d_key = 1; }, undefined, function() { this.d_key = 0; } ); this.new_line();
      this.key_triggered_button( "Drop claw", "enter", function() { this.enter_key = 1; }, "red", function() { this.enter_key = 0; } ); this.new_line();
      this.key_triggered_button( "Toggle controls", "c", function()
                                                          {
                                                            this.globals.movement_target_is_a_camera = !this.globals.movement_target_is_a_camera;
                                                            this.globals.target_is_claw = !this.globals.movement_target_is_a_camera;
                                                          }, "red" ); this.new_line();
                                                          
      
    }
  
  move_transform( meters_per_frame )
    {
      let min_x = -10;
      let max_x = 10;
      let min_z = -10;
      let max_z = 10;
      
      let move_thrust = Vec.of( this.thrust[0], 0, this.thrust[2] );
      this.get_claw_tf().post_multiply( Mat4.translation( move_thrust.times( -meters_per_frame ) ) );
      
      // Determine whether clamp is needed
      let clamp_needed = false;
      let clamped_x = false;
      let clamped_z = false;
      let clamped_target = Mat4.identity().times( this.get_claw_tf() );
      
      if ( clamped_target[0][3] > max_x)
        {
          clamp_needed = true;
          move_thrust[0] = 0;
          clamped_target[0][3] = max_x;
        }
      else if ( clamped_target[0][3] < min_x )
        {
          clamp_needed = true;
          move_thrust[0] = 0;
          clamped_target[0][3] = min_x;
        }
      if ( clamped_target[2][3] > max_z)
        {
          clamp_needed = true;
          move_thrust[3] = 0;
          clamped_target[2][3] = max_z;
        }
      else if ( clamped_target[2][3] < min_z )
        {
          clamp_needed = true;
          move_thrust[3] = 0;
          clamped_target[2][3] = min_z;
        }
      
      // Clamp the claw_tf transform
      if (clamp_needed)
        {
          this.set_claw_tf( clamped_target );
        }
      
      this.set_claw_velocity( move_thrust );
    }
  
  parse_input()
    {
      // Thrust
      this.thrust = Vec.of( 0, 0, 0 );
      if (this.w_key)
        {
          this.thrust[2] += 1;
        }
      if (this.s_key)
        {
          this.thrust[2] += -1;
        }
      if (this.a_key)
        {
          this.thrust[0] += 1;
        }
      if (this.d_key)
        {
          this.thrust[0] += -1;
        }
      
      if (this.enter_key)
        {
          this.set_button_pressed( true );
          if (!this.globals.is_grabbing && !this.globals.is_returning && !this.globals.is_dropping_prize)
            {
              this.globals.is_grabbing = true;
            }
        }
      else
        {
          this.set_button_pressed( false );
        }
    }

  rotate_joystick()
    {
      let rotate_z = Mat4.rotation( this.thrust[2] * Math.PI/8, Vec.of( 0, 0, 1 ) );
      let rotate_x = Mat4.rotation( this.thrust[0] * Math.PI/8, Vec.of( 1, 0, 0 ) );
      
      this.set_joystick_rot_tf( rotate_x.times( rotate_z ) );
    }
    
  display( graphics_state, dt = graphics_state.animation_delta_time )           // Camera code starts here.
    {
      if ( this.target_is_claw() )
        {
          this.parse_input();
          
          if ( !this.is_grabbing() && !this.is_returning() && !this.is_dropping_prize() )
            {
              this.move_transform( dt / 100 );
            }
            
          this.rotate_joystick();
        }
    }
}
    
class My_Animation extends Scene_Component  // Code your butterfly assignment below.  It is an example of drawing a hierarchical object using a "model_transform" matrix.
{ constructor( context )
    { super( context );
      let shapes = { "box" :   new Cube(),                            // Load one of each of these shape definitions onto the GPU.  Once each Shape is there we 
                     "ball":   new Subdivision_Sphere( 4 ),           // re-use it many times per display() call to get multiple of that shape to appear in the scene.
                     "teapot": new Shape_From_File( "/assets/teapot.obj" ),
                     "claw_arm": new Shape_From_File( "/assets/claw_arm.obj" ),
                     "claw_machine": new Shape_From_File( "/assets/claw_machine.obj" ),
                     "window": new Shape_From_File( "/assets/window.obj" ),
                     "joystick": new Shape_From_File( "/assets/joystick.obj" ),
                     "button": new Shape_From_File( "/assets/button.obj" ),
                     "square_pyramid": new Square_Pyramid(),
                     "diamond": new Diamond(),
                     "capped_cylinder": new Capped_Cylinder ( 4, 50, [[0,1],[0,1]] ),
                     "donut" : new Torus ( 15, 15 ),
                     "tiled_square_50": new Tiled_Square( 50, 50 ),
                     "tiled_square_17": new Tiled_Square( 17, 17 ),
                     "square": new Square()
                     };
                     
      this.submit_shapes( context, shapes );
                                                                      // Define the global camera and projection matrices.  
                                                                      // Arguments to perspective() are field of view, aspect ratio, near plane and far plane.
      Object.assign( context.globals.graphics_state, { camera_transform: Mat4.translation([ 0,-10,-60 ]).times( Mat4.rotation( Math.PI/12, Vec.of( 1, 0, 0 ) ) ), projection_transform: Mat4.perspective( Math.PI/4, context.width/context.height, .1, 1000 ) } );
      
      Object.assign( this, { text_image: context.get_instance( Phong_Model ).material( Color.of( 0,0,0,1 ), 1, 0, 0, 1, context.get_instance( "/assets/text.png" ) ) } );
                       
      Object.assign( this, { hover: false, t: 0, fps: 0,
                             yellow: context.get_instance( Phong_Model ).material( Color.of( .8, .8, .3,  1 ), .2, 1, .7, 40 ),  // Call material() on the Phong_Shader,
                             brown:  context.get_instance( Phong_Model ).material( Color.of( .3, .3, .1,  1 ), .2, 1,  1, 40 ),  // which returns a special-made "material" 
                             red:    context.get_instance( Phong_Model ).material( Color.of(  1,  0,  0, .9 ), .1, .7, 1, 40 ),  // (a JavaScript object)
                             green:  context.get_instance( Phong_Model ).material( Color.of(  0, .5,  0,  1 ), .1, .7, 1, 40 ),
                             blue:   context.get_instance( Phong_Model ).material( Color.of(  0,  0,  1, .8 ), .1, .7, 1, 40 ),
                             silver: context.get_instance( Phong_Model ).material( Color.of( .5, .5, .5,  1 ),  .5,  1, 1, 40 ),
                             dark_silver: context.get_instance( Phong_Model ).material( Color.of( .5, .5, .5,  1 ),  .3, .3, .3, 40 ),
                             window_color: context.get_instance( Phong_Model ).material( Color.of( .7, .7, .7,  .05 ),  .1,  .1, .1, 40 ),
                             joystick_color: context.get_instance( Phong_Model ).material( Color.of( 1, 1, 1,  1 ),  .1,  .1, .1, 40 ),
                             button_color: context.get_instance( Phong_Model ).material( Color.of( .8, .1, .1,  1 ),  .8,  .8, 1, 40 ),
                             button_color_flash: context.get_instance( Phong_Model ).material( Color.of( 1, 0, 0,  1 ),  1,  1, 1, 40 ),
                             purple: context.get_instance( Phong_Model ).material( Color.of(  60/255,  30/255,  130/255, 1 ), 0, 1, 1, 40 ),
                             diamond: context.get_instance( Phong_Model ).material( Color.of( .5 , .5, .5, 1 ), .8, .2, .5, 40, context.get_instance( "assets/diamond.png" ) ),
                             black: context.get_instance( Phong_Model ).material( Color.of( 0, 0, 0, 1 ), .1, .7, 1, 40 ),
                             arcade_carpet: context.get_instance( Phong_Model ).material( Color.of( 0, 0, 0, 1 ), .4, 0, 0, 40, context.get_instance( "assets/arcade_carpet.jpg" ) ),
                             terry_crews: context.get_instance( Phong_Model ).material( Color.of( 0, 0, 0, 1 ), .8, 0, 0, 40, context.get_instance( "assets/terry_crews.jpg" ) ),
                             brick: context.get_instance( Phong_Model ).material( Color.of( 0, 0, 0, 1 ), .06, 0, 0, 40, context.get_instance( "assets/brick.jpg" ) ),
                             gradient_bw: context.get_instance( Phong_Model ).material( Color.of( .4, .4, .4, 1 ), .7, 0, 0, 40, context.get_instance( "assets/gradient_bw.png" ) )
                           });
                             
      // Whether the target of the controls is the claw
      this.target_is_claw = function() { return context.globals.target_is_claw }
      
      // Flag: drop animation
      this.is_grabbing = function() { return context.globals.is_grabbing };
      
      // Flag: return animation
      this.is_returning = function() { return context.globals.is_returning };
      
      // Claw transform
      this.get_claw_tf = function() { return context.globals.claw_tf };
      this.set_claw_tf = function( new_claw_tf ) { context.globals.claw_tf = new_claw_tf };
      
      // Flag: grip animation
      this.is_gripping_claw = function() { return context.globals.is_gripping_claw };
      
      // Flag: release animation
      this.is_releasing_claw = function() { return context.globals.is_releasing_claw };
      
      // Claw arm rotation transform
      this.get_claw_rot_tf = function() { return context.globals.claw_rot_tf };
      this.set_claw_rot_tf = function( new_claw_rot_tf ) { context.globals.claw_rot_tf = new_claw_rot_tf };
      
      // Joystick rotation transform
      this.get_joystick_rot_tf = function() { return context.globals.joystick_rot_tf };
      this.set_joystick_rot_tf = function( new_joystick_rot_tf ) { context.globals.joystick_rot_tf = new_joystick_rot_tf };
      
      // Flag: drop prize animation
      this.is_dropping_prize = function() { return context.globals.is_dropping_prize };
      
      // Prize transform
      this.get_prize_tf = function() { return context.globals.prize_tf };
      this.set_prize_tf = function( new_prize_tf ) { context.globals.prize_tf = new_prize_tf };
      
      // Picked up item transform
      this.get_pickup_tf = function() { return context.globals.pickup_tf };
      this.set_pickup_tf = function( new_pickup_tf ) { context.globals.pickup_tf = new_pickup_tf };
      
      // Flag: target is camera
      this.target_is_a_camera = function() { return context.globals.movement_target_is_a_camera };
      
      // Camera transform
      this.get_cam_tf = function() { return context.globals.graphics_state.camera_transform }
      this.set_cam_tf = function( new_cam_tf ) { context.globals.graphics_state.camera_transform = new_cam_tf };
			
			// Flag: item picked up
			this.set_item_picked_up = function(x) { context.globals.item_picked_up = x; };
      this.get_item_picked_up = function() { return context.globals.item_picked_up };
      context.globals.item_picked_up = false;
      
      // Number of the item picked up
      this.get_item_num = function( num ) { return context.globals.item_num; };
      this.set_item_num = function( num ) { context.globals.item_num = num; };
      context.globals.item_num = -1;
      
      // Flag: drop prize animation
      this.is_dropping_prize = function() { return context.globals.is_dropping_prize };
      this.get_prize_tf = function() { return context.globals.prize_tf };
      this.set_prize_tf = function( new_prize_tf ) { context.globals.prize_tf = new_prize_tf };
      
      // Item array
      this.items_tfs = new Array(2).fill( Mat4.identity() );
      this.items_models = [
          this.shapes.teapot,
          this.shapes.diamond
        ];
      this.items_won = function() { return context.globals.items_won };
      context.globals.items_won = new Array(2).fill(false);
      
      // Flag: button pressed
      context.globals.button_pressed = false;
      this.get_button_pressed = function() { return context.globals.button_pressed };
      this.set_button_pressed = function( new_button_pressed ) { context.globals.button_pressed = new_button_pressed };
      
      // Claw actual velocity
      this.get_claw_velocity = function() { return context.globals.claw_velocity };
      this.set_claw_velocity = function( new_vel ) { context.globals.claw_velocity = new_vel };
      
      ///////////////////////////////////////
      ///////////////// tts /////////////////
      ///////////////////////////////////////
      Object.assign( this, { orange: context.get_instance( Phong_Model ).material( Color.of( .8,.4,0,1 ), .3, .8, .8, 40, context.get_instance( "/assets/rgb.jpg" ) ), globals: context.globals,
                     nodes: [], segments: [], time_accumulator: 0, time_scale: 1/2000, t: 0, dt: 1/500, N: 40  } );            // Define the step size for time, and the amount of
      this.reset();
      
    }
    
  make_control_panel() // Draw the buttons, setup their actions and keyboard shortcuts, and monitor live variables.
    {
      this.live_string( () => { return "FPS: " + this.fps } ); this.new_line();
    }

  display( graphics_state )
    {
      this.fps = Math.round( 1/graphics_state.animation_delta_time * 1000 );
      
      graphics_state.lights = [ new Light( Vec.of(  30, 80,  34, 1 ), Color.of( 60/255, 30/255, 120/255, 1 ), 20000 ), // point purple from top
                                new Light( Vec.of(  30, -100,  34, 1 ), Color.of( 151/255, 255/255, 255/255, 1 ), 5000 ), // point teal from bottom
                                new Light( Vec.of( 100, 50, 150, 1 ), Color.of( 60/255, 30/255, 120/255, 1 ), 10000 ), // point purple from front
                              ]
      
      // Useful variables that are used throughout the display() function
      let rotate_x = Mat4.identity();
      let rotate_y = Mat4.identity();
      let rotate_z = Mat4.identity();
      let rotate = Mat4.identity();
      let scale = Mat4.identity();

      // Start drawing the scene
      let model_transform = Mat4.identity();
      
			let origin_tf = model_transform;
      
      // Floor
      let floor_tf = origin_tf.times( Mat4.translation( Vec.of( 0, -31, 0 ) ) );
      scale = Mat4.scale( Vec.of( 500, 500, 500 ) );
      rotate = Mat4.rotation( Math.PI/2, Vec.of( 1, 0, 0 ) );
      this.shapes.tiled_square_50.draw( graphics_state, floor_tf.times( rotate ).times( scale ), this.arcade_carpet );
      
      // Wall
      let wall_tf = floor_tf.times( Mat4.translation( Vec.of( 0, 51.8, -20 ) ) );
      scale = Mat4.scale( Vec.of( 500, 500, 500 ) );
      this.shapes.tiled_square_17.draw( graphics_state, wall_tf.times( scale ), this.brick );

      // Claw machine
      let claw_machine_tf = origin_tf.times( Mat4.translation( Vec.of( -1, 16, 4 ) ) ).times( Mat4.rotation( Math.PI * -1/2, Vec.of( 0, 1, 0 ) ) );
      let claw_machine_scale = 35;
      scale = Mat4.scale( Vec.of( claw_machine_scale, claw_machine_scale, claw_machine_scale ) );
      this.shapes.claw_machine.draw( graphics_state, claw_machine_tf.times( scale ), this.purple );
      
      // Claw machine's windows
      let window_scale = claw_machine_scale * 23/30;
      scale = Mat4.scale( Vec.of( window_scale, window_scale, window_scale ) )
      let claw_machine_center_tf = claw_machine_tf.times( Mat4.translation( Vec.of( -4.5, 4.7, -.7 ) ) );
      
      for ( let rot of [ 0, Math.PI * 1/2, Math.PI * 1] )
        {
          rotate_y = Mat4.rotation( rot, Vec.of( 0, 1, 0 ) );
          let window_tf = claw_machine_center_tf.times( rotate_y ).times( Mat4.translation( Vec.of( 0, 0, -1 * window_scale * 18/30 ) ) );
          
          this.shapes.window.draw( graphics_state, window_tf.times( scale ), this.window_color );
        }
        
      // Claw machine's hole bordering windows
      let border_window_scale = claw_machine_scale * 5/30
      scale = Mat4.scale( Vec.of( border_window_scale * 1.02, border_window_scale * 0.5, border_window_scale * 0.01) )
      let prize_hole_center_tf = claw_machine_tf.times( Mat4.translation( Vec.of( 6, -14, 9.2 ) ) );
      
      for ( let rot of [ 0, Math.PI * 1/2] )
        {   
          rotate_y = Mat4.rotation( rot, Vec.of( 0, 1, 0 ) );
          let border_window_tf = prize_hole_center_tf.times( rotate_y ).times( Mat4.translation( Vec.of( 0, 0, -1 * window_scale * 6.8/30 ) ) );
          
          this.shapes.box.draw( graphics_state, border_window_tf.times( scale ), this.window_color );
        }
        
      // Claw machine's joystick
      let joystick_scale = claw_machine_scale * 2/30
      scale = Mat4.scale( Vec.of( joystick_scale, joystick_scale , joystick_scale ) )
      let joystick_tf = claw_machine_tf.times( Mat4.translation( Vec.of( 17.5, -15.5, 2.5 ) ) );
      
      rotate = Mat4.translation( Vec.of( 0, -2.5, 0 ) ).times( this.get_joystick_rot_tf() ).times( Mat4.translation( Vec.of( 0, 2.5, 0 ) ) );
      rotate_z = Mat4.rotation( Math.PI * -1/25, Vec.of( 0, 0, 1 ) )
      this.shapes.joystick.draw( graphics_state, joystick_tf.times( rotate_z ).times( rotate ).times( scale ), this.joystick_color )
      
      // Claw machine's button
      let button_scale = claw_machine_scale * 2/55
      scale = Mat4.scale( Vec.of( button_scale, button_scale , button_scale ) )
      let button_tf = claw_machine_tf.times( Mat4.translation( Vec.of( 16.8, -17.95, -3.5 ) ) );
      let button_pressed_tf = button_tf.times( Mat4.translation( Vec.of( 0, -.5, 0 ) ) );
      
      rotate_z = Mat4.rotation( Math.PI * -1/19, Vec.of( 0, 0, 1 ) )
      
      if ( this.get_button_pressed() )
        {
          this.shapes.button.draw( graphics_state, button_pressed_tf.times( rotate_z ).times( scale ), this.button_color_flash );
        }
      else
        {
          this.shapes.button.draw( graphics_state, button_tf.times( rotate_z ).times( scale ), this.button_color );
        }
      
      // Potential prizes
      
      for ( let i = 0; i < this.items_tfs.length; i++ )
        {
          this.items_tfs[i] = origin_tf.times( Mat4.translation( Vec.of( 3*i, 2.1, 3*i ) ) );
        }
      
      if ( this.get_item_picked_up() )
        {
          this.items_tfs[ this.get_item_num() ] = this.get_prize_tf();
          //cip
          //this.items_tfs[ this.get_item_num() ] = this.get_pickup_tf();
        }
      
      //console.log( this.get_pickup_tf().times( Vec.of( 0, 0, 0, 1 ) ) );
      
      for (let i = 0; i < this.items_tfs.length; i++)
        {
          // If item won, place it in the "graveyard" at -100
          if ( this.items_won()[i] )
            {
              this.items_tfs[i] = origin_tf.times( Mat4.translation( Vec.of( -100, -100, -100 ) ) );
            }
          else // Draw item if not won
            {
              this.items_models[i].draw( graphics_state, this.items_tfs[i].times( Mat4.scale( Vec.of( 2, 2, 2 ) ) ), this.diamond );
            }
        }
        
      // Claw
      let claw_tf = this.get_claw_tf();
      this.draw_claw( graphics_state, claw_tf, this.silver );
      
      // Claw's support bars
      let support_bar_h = 41  ;
      
      let support_bar_tf_z = Mat4.translation( Vec.of( 0, support_bar_h, 0 ) );
      support_bar_tf_z[2][3] = claw_tf[2][3];
      this.shapes.box.draw( graphics_state, support_bar_tf_z.times( Mat4.scale( Vec.of( 16, 1, 1 ) ) ), this.dark_silver );
      
      let support_bar_tf_x = Mat4.translation( Vec.of( 0, support_bar_h, 0 ) );
      support_bar_tf_x[0][3] = claw_tf[0][3];
      this.shapes.box.draw( graphics_state, support_bar_tf_x.times( Mat4.scale( Vec.of( 1, 1, 16 ) ) ), this.dark_silver );
      
      let support_bar_bearing = Mat4.translation( Vec.of( 0, support_bar_h, 0 ) );
      support_bar_bearing[2][3] = claw_tf[2][3];
      support_bar_bearing[0][3] = claw_tf[0][3];
      this.shapes.ball.draw( graphics_state, support_bar_bearing.times( Mat4.scale( Vec.of( 2.5, 2.5, 2.5 ) ) ), this.dark_silver );
      
      if ( this.is_gripping_claw() )
        {
          // Detecting if a "prize" was won
          let claw_hitbox_tf = claw_tf.times( Mat4.translation( Vec.of( 0, -5, 0 ) ) );
          //this.shapes.ball.draw( graphics_state, claw_hitbox_tf.times( Mat4.scale( Vec.of( 1, 1, 1 ) ) ), this.transparent );
          let hit_radius = 2;
          
          
          this.set_item_picked_up(false);
          for (let i = 0; i < this.items_tfs.length; i++)
            {
              let dist_vec = this.items_tfs[i].times( Vec.of( 0, 0, 0, 1 ) ).minus( claw_hitbox_tf.times( Vec.of( 0, 0, 0, 1 ) ) ).to3();
              dist_vec[1] = 0;
              let dist_to_toy = Math.sqrt( dist_vec.dot( dist_vec ) );
              
              if ( dist_to_toy < 2 )
                {
                  <!-- //cip -->
                  <!-- if ( this.get_item_num != i ) -->
                    <!-- { -->
                      <!-- this.set_pickup_tf( this.items_tfs[i] ) -->
                      <!-- console.log( this.get_pickup_tf() ) -->
                    <!-- } -->
                
                  this.set_item_picked_up(true);
                  this.set_item_num(i);
                  break;
                }
            }
        }
      
      // TODO:
      //    make better texture mapping for diamond shape?
      
      //    add music
      //      - stranger things/retro/8-bit type of music?
      //    add "distance" text to get player feedback to how close they were to the item
      //      - for dist between 2 and 4, output text above items transform
      //    construct rest of scene (other arcade machines, lighting, cheesy carpet,...)
      //      - arcade machines (very small width + tranparent -> looks like tv screen)
      //      - lighting (figure this out lol)
      //    add smoother "capture" animation
      //      - interpolate between prize_tf and a "pickup_tf"
      //    smoother camera animations
      //      - interpolate camera parameters (P_eye/P_ref)
      //      - do it in coroutine?
      //    make movie?
      
      // TTS
      if( this.globals.animate ) this.simulate( graphics_state.animation_delta_time );                 // Advance the time and state of our whole simulation.
      this.blend_state();
      
      let previous_point;                                                                              // Begin drawing the spring.
      for( let n of this.nodes )
      { let target = previous_point;                                                                   // When drawing, point each segment at the previous one using look_at().
        if( !previous_point || previous_point.equals( n.drawn_position ) ) target = Vec.of( 0,10,0 );
    
        let matrix = Mat4.inverse( Mat4.look_at( n.drawn_position, target, Vec.of( 0,0,1 ) ) );        // Remember to invert the result of look_at() since it is originally for cameras. 
        previous_point = Vec.of( ...n.drawn_position );        
        this.shapes.donut.draw( graphics_state, claw_tf.times( Mat4.translation( Vec.of( 1.2, -1, 0 ) ) ).times( matrix ).times( Mat4.scale( [ .3, .3, .3 ] ) ), this.black );       // Draw the spring segment.
      }
    }
    
  reset()       // Define a data structure for the spring, organizing some data the reside at the nodes (0D points) and some at the springs (1D line segments).
    { for( let i = 0; i < this.N;   i++ ) this.nodes[i] = { neighbors: [ i > 0 && i-1, i < this.N-1 && i ], previous_pos: Vec.of( 0,0,0 ), velocity: Vec.of( 0,0,0 ) };   // Define nodes.
      //this.nodes.forEach( (n,i,a) => n.position = Mat4.rotation( 2*Math.PI*i/a.length, Vec.of( 0,1,0 ) ).times( Vec.of( -1,2,0,1 ) ).to3() );    // Initial position of nodes: a circle.
      //this.nodes.forEach( (n,i,a) => n.position = Vec.of( i, 0.2 * i, 0 ) );
      this.nodes.forEach( (n, i, a) => n.position = Vec.of( i*0.1, Math.pow( i*0.1 + 1, 2 ) * 1.2, 0 ) );
      
      for( let i = 0; i < this.N-1; i++ ) this.segments[i] = { endpoints: [ i, i+1 ], dS: this.nodes[i+1].position.minus( this.nodes[i].position ).norm(),    // Connect neighboring nodes with
                                                               spring_force: Vec.of( 0,0,0 ), spring_damper_force: Vec.of( 0,0,0 ) };                         // 1D spring segments.
      this.segments[ false ] =                               { spring_force: Vec.of( 0,0,0 ), spring_damper_force: Vec.of( 0,0,0 ) };   // Define an extra segment to stand in for undefined ones 
    }                                                                                                                                   // beyond boundaries.  Tension force is always zero there.
  simulate( frame_time )                                              // Carefully advance time according to Glenn Fielder's "Fix Your Timestep" blog post. 
    { frame_time = this.time_scale * frame_time;                      // This line lets us create the illusion to the simulator that the display framerate is running fast or slow.
      this.time_accumulator += Math.min( frame_time, 0.1 ) ;	        // Avoid the spiral of death; limit the amount of time we will spend computing during this timestep if display lags.
      while ( Math.abs( this.time_accumulator ) >= this.dt )			    // Repeatedly step the simulation until we're caught up with this frame.
      { this.update_state( this.t, this.dt );                         // Single step of the simulation for all bodies.
        
        this.t                += Math.sign( frame_time ) * this.dt;   // Following the advice of the article, de-couple our simulation time from our frame rate.
        this.time_accumulator -= Math.sign( frame_time ) * this.dt;
      }     
      this.alpha = this.time_accumulator / this.dt;                   // Store an interpolation factor for how close our frame fell in between the two latest simulation time steps, so
    }                                                                 // we can correctly blend the two latest states and display the result.
  blend_state() { for( let n of this.nodes ) n.drawn_position = n.previous_pos.mix( n.position, this.alpha ) }   // Blend our two most recent simulation states.  
  update_state( t, dT )                                         // Apply the known forces in our particular setup to the velocities.  Then apply those to the positions using forward Euler.
    { const K = 150, Kd = 1.4 * K, g = Vec.of( 0,-9.8,0 ).plus( this.get_claw_velocity().times( 10 ) );       // Set physical constants.
      
      for( let curr_seg of this.segments )
      { let [p1, p2]              = curr_seg.endpoints.map( i => { return this.nodes[i].position }, this),
            [v1, v2]              = curr_seg.endpoints.map( i => { return this.nodes[i].velocity }, this),
            dPHI_dS               = p2.minus( p1 ).times( 1/curr_seg.dS );
        let [ length, direction ] = [ dPHI_dS.norm(), dPHI_dS.normalized() ];
        
        // TODO:  Create a non-zero length for the spring segment's rest state and apply it to the formula here.
        curr_seg.spring_force          = dPHI_dS.times( K*( length - .1 )/length ).times( 1/curr_seg.dS );
        
        // TODO:  Calculate the magnitude and direction of the damping force acting upon this spring segment along the segment's direction, and store it here:
        //        ( Hint:  Use the variables direction, v1, v2, Kd, and 1/curr_seg.dS )
        curr_seg.spring_damper_force   = v1.minus(v2).times(-1 * Kd);
      }
      
      // Propagate the foreces from the spring segments to their adjacent nodes.  Wherever either neighbor is undefined, use the placeholder one from before instead:
      let spring_force_at_node = (n) => { return n.force.plus( this.segments[ n.neighbors[1] ].spring_force       .minus( this.segments[ n.neighbors[0] ].spring_force        ) ); },
          damper_force_at_node = (n) => { return n.force.plus( this.segments[ n.neighbors[1] ].spring_damper_force.minus( this.segments[ n.neighbors[0] ].spring_damper_force ) ); };
          
      ( function  zeroize_forces( nodes ) { for( let n of nodes ) n.force = Vec.of( 0,0,0 );                         } )( this.nodes );  // Sum the finished forces.
      ( function   spring_forces( nodes ) { for( let n of nodes ) n.force = n.force.plus( spring_force_at_node(n) ); } )( this.nodes );  
      ( function  damping_forces( nodes ) { for( let n of nodes ) n.force = n.force.plus( damper_force_at_node(n) ); } )( this.nodes );
      ( function external_forces( nodes ) { for( let n of nodes ) n.force = n.force.plus( g                       ); } )( this.nodes );
      
      for( let n of this.nodes ) n.velocity = n.velocity.plus( n.force.times( dT ) );                                      // Apply the finished forces to velocity.
      let final = this.nodes[ this.nodes.length-1 ];
      final.velocity = final.velocity.minus( damper_force_at_node( final ).times( dT/6 ) ).minus( g.times( dT/2 ) );       // Carefully handle the mass of the last node.
      this.nodes[ 0 ].velocity = Vec.of( 0,0,0 );                                                                 // Apply this scene's boundary condition(s):  Fix the first node in place.
                                                                                                                  // TODO:  Try fixing more than one node in place.
     
      this.nodes[ this.N - 1 ].velocity = Vec.of( 0, 0, 0 );
                                                                                                                  
      this.advance( dT );
    }
  advance( dT )                                                         // Forward-Euler position update 
  { for( let n of this.nodes )
      { n.previous_pos = Vec.of( ...n.position );
        n.position = n.position.plus( n.velocity.times( dT ) );         // Add each node's instantaneous velocity at time t.
      }
  }
  /////////////////////////////////////////////////
  
	// Drawn with origin at bearing, palm facing downward
	draw_claw( graphics_state, model_transform, color )
    {
      let rotate_x = Mat4.identity();
      let rotate_y = Mat4.identity();
      let rotate_z = Mat4.identity();

      let bearing_tf = model_transform;
      this.shapes.ball.draw( graphics_state, bearing_tf, color );
      
      let claw_neck_tf = bearing_tf.times( Mat4.translation( Vec.of( 0, 10, 0 ) ) );
      this.shapes.capped_cylinder.draw( graphics_state, claw_neck_tf.times( Mat4.scale( Vec.of( 1, 20, 1 ) ) ).times( Mat4.rotation( Math.PI * 1/2, Vec.of( 1, 0, 0 ) ) ), color );
      
      for ( let rot of [ 0, Math.PI * 2/3, Math.PI * 4/3 ] )
        {
          rotate_x = Mat4.rotation( Math.PI/5, Vec.of( 1, 0, 0 ) ); // Alter this to open/close claws!
          rotate_x.post_multiply( this.get_claw_rot_tf() ); // Adding the claw grip animation
            
          rotate_y = Mat4.rotation( rot, Vec.of( 0, 1, 0 ) );
          let claw_arm_tf = bearing_tf.times( rotate_y ).times( rotate_x ).times( Mat4.translation( Vec.of( 0, -1.5, 5 ) ) );
          
          this.draw_claw_arm( graphics_state, claw_arm_tf, color );
        }
    }
    
  draw_claw_arm( graphics_state, model_transform, color )
    {
      let claw_arm_tf = model_transform;
      this.shapes.claw_arm.draw( graphics_state, claw_arm_tf.times( Mat4.scale( Vec.of( 2, 2, 2 ) ) ), color );
    }
}


</script>
<style>
  table { border-collapse: collapse; display:block; overflow-x: auto; }
  table, th, td { border: 2px solid black; vertical-align: top; white-space: nowrap }
  th, td { overflow: hidden;  }
  button { position: relative; background-color: #4C9F50; color: white; padding: 6px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); transition: background-color .3s, transform .3s }
  button:hover, button:focus { transform: scale(1.2); color:gold }
  .dropdown { display:inline-block }
  .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; min-width: 100px; overflow: auto; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2) }
  .dropdown-content a { color: black; padding: 4px 4px; display: block }
  .dropdown a:hover { background-color: #f1f1f1 }
  .show { display:inline-block }
</style>
</head><body>
<div id="explanation_section"></div>
<div id="canvases"></div>
<table id="control_buttons" class="dropdown" style="display:block; width: 70%;  border: 0px; margin: 0 0 50px 0"><tr></tr></table>
<div id="code_panel" style="font-family: monospace; white-space: pre; margin: 50px 0" >
  <div id="code_display"  data-displayed="" ></div>
  <button id="edit_button" style="display:none">Start editing</button> 
  <table id="class_list" class="dropdown" style="display:block; border: 0px; border-spacing: 10px " >
    <tr><td colspan="2">Click below to navigate through all classes that are defined. <br>&nbsp;<br>Main demo: <span name="main_demo_link"></span></td></tr>
    <tr style="text-align:center"><td>tinywebgl-ucla.js</td><td>dependencies.js</td></tr><tr></tr></table>
</div>
<form name="new_demo_source_code" style="display:none">  
  <p style="margin: 50px 0"><i><b>What can I put here?</b></i>  A JavaScript class, with any valid JavaScript inside.  Your code can use classes from this demo, or from ANY demo on the 
  encyclopedia of code --  the dependencies will automatically be pulled in to run your demo!<br></p>
  <textarea rows="30" cols="140" name="new_demo_code"></textarea><br>
  <div id="submit_result" style="margin: 10px 0"></div>
  <button type="submit" style="margin: 0px 50px 0px 0px">Save as new webpage</button> 
  <input type="text" name="author"   placeholder="Author name">
  <input type="text" name="password" placeholder="Password" style="display:none">
  <span id="overwrite_panel" style="display:none"><label>Overwrite?<input type="checkbox" name="overwrite" autocomplete="off"></label></span>
  <span id="beginner_panel"><label>Beginner Mode<input type="checkbox" checked onchange="document.querySelector('#expert_panel').style.display='block'; beginner_panel.style.display='none'"></label></span>
  <div id="expert_panel" style="display:none;"><label><input type="checkbox" name="finished" autocomplete="off">
    Optional:  This demo is finished; consider it for public listing on the main page.  
    I believe that this demo is the one true way to minimalistically do what its name says.
    The code's readability and structure are so good as to maximize how easy it is to memorize it.
    </label></div>  
</form>
</body></html>